<!DOCTYPE html>
<html>
<head>
    <title>Dante's Rings</title>
    <link rel="apple-touch-icon" href="Dante_App_Logo.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        :root { --roblox-blue: #00A2FF; --roblox-green: #00E676; --accent: #FF1493; }
        body { 
            background: url('Roblox_Bg.jpg') no-repeat center center fixed; background-size: cover;
            color: white; margin: 0; overflow: hidden; font-family: 'Comic Sans MS', sans-serif; 
            touch-action: none; display: flex; flex-direction: column; align-items: center; height: 100vh;
        }
        #ui-header { height: 10vh; width: 100%; text-align: center; padding-top: 5px; z-index: 10; background: rgba(0,0,0,0.4); backdrop-filter: blur(5px); }
        #main-layout { display: flex; width: 98vw; height: 78vh; justify-content: center; align-items: center; gap: 8px; position: relative; z-index: 5; }
        .sidebar { display: flex; flex-direction: column; justify-content: center; gap: 5px; width: 60px; }
        .box { background: rgba(0,0,0,0.6); border: 3px solid #FFF; border-radius: 12px; height: 60px; display: flex; align-items: center; justify-content: center; position: relative; }
        #dante-avatar { position: absolute; top: -55px; left: 0; width: 55px; height: 55px; transition: 0.2s; }
        #dante-avatar img { width: 100%; height: 100%; object-fit: contain; filter: drop-shadow(3px 3px 0px rgba(0,0,0,0.3)); }
        #game-container { position: relative; height: 100%; aspect-ratio: 10 / 20; border: 6px solid #FFF; border-radius: 20px; background: rgba(0,0,0,0.5); overflow: hidden; }
        canvas#tetris { width: 100%; height: 100%; display: block; }
        #progress-container { width: 70%; height: 10px; background: rgba(0,0,0,0.3); border: 2px solid #FFF; border-radius: 10px; margin: 5px auto; overflow: hidden; }
        #progress-fill { width: 0%; height: 100%; background: var(--roblox-green); box-shadow: 0 0 10px var(--roblox-green); transition: width 0.3s; }
        .bottom-bar { display: flex; gap: 15px; padding: 10px; height: 10vh; z-index: 10; }
        .action-btn { width: 80px; height: 60px; border-radius: 15px; border: 3px solid #FFF; background: var(--roblox-blue); font-size: 24px; color: white; box-shadow: 0 5px 0px #0077be; }
        #start-overlay, #overlay { position: absolute; inset: 0; background: rgba(0, 162, 255, 0.95); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; text-align: center; }
        .overlay-btn { padding: 15px 35px; background: var(--roblox-green); color: white; border: 5px solid white; border-radius: 40px; font-size: 24px; font-weight: bold; box-shadow: 0 6px 0px #009624; margin-top: 15px; }
        #win-image { width: 160px; margin-bottom: 10px; display: none; border-radius: 15px; }
        #mute-btn { position: absolute; top: 10px; right: 10px; width: 40px; height: 40px; background: rgba(255,255,255,0.2); border: 2px solid #FFF; border-radius: 50%; display: flex; align-items: center; justify-content: center; z-index: 1100; }
    </style>
</head>
<body onpointerdown="unlockAudio()">

    <div id="mute-btn" onclick="toggleMute()">ðŸ”Š</div>

    <div id="start-overlay">
        <img src="Dante_App_Logo.png" style="width:140px; margin-bottom:15px;">
        <h1 style="font-size: 36px; margin: 0;">DANTE'S RINGS</h1>
        <p>Follow your finger to move!</p>
        <button class="overlay-btn" onclick="startGame()">START GAME</button>
    </div>

    <div id="ui-header">
        <b id="level-title">Underwater World</b><br>
        <small>Score: <span id="score">0</span> | Lines: <span id="lines-count">0</span></small>
        <div id="progress-container"><div id="progress-fill"></div></div>
    </div>
    
    <div id="main-layout">
        <div class="sidebar">
            <small style="font-weight:bold;">HOLD</small>
            <div class="box">
                <div id="dante-avatar"><img src="Dante_App_Logo.png"></div>
                <canvas id="hold-canvas" width="50" height="50"></canvas>
            </div>
        </div>
        <div id="game-container">
            <canvas id="tetris" width="200" height="400"></canvas>
            <div id="overlay" style="display:none; background: rgba(0,0,0,0.9);">
                <img id="win-image" src="Youwin.png">
                <h2 id="overlay-title">PAUSED</h2>
                <p id="overlay-text" style="font-size:14px; max-width:220px;"></p>
                <button class="overlay-btn" id="overlay-primary-btn" onclick="resumeGame()">CONTINUE</button>
            </div>
        </div>
        <div class="sidebar">
            <small style="font-weight:bold;">NEXT</small>
            <div class="box"><canvas id="next-canvas" width="50" height="50"></canvas></div>
        </div>
    </div>

    <div class="bottom-bar">
        <button class="action-btn" onpointerdown="playerHold()">ðŸ“¦</button>
        <button class="action-btn" onpointerdown="playerRotate(1)">ðŸ”„</button>
    </div>

<script>
// --- DOM REFERENCES ---
const overlay = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlay-title');
const overlayText = document.getElementById('overlay-text');
const overlayPrimaryBtn = document.getElementById('overlay-primary-btn');
const progressFill = document.getElementById('progress-fill');
const danteAvatar = document.getElementById('dante-avatar');
const levelTitle = document.getElementById('level-title');

// --- AUDIO ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const bgMusic = new Audio('Dantesgamemusic.m4a');
bgMusic.loop = true; bgMusic.volume = 0.4;
let isMuted = false, audioUnlocked = false;

function unlockAudio() {
    if (!audioUnlocked && audioCtx.state === 'suspended') audioCtx.resume();
    audioUnlocked = true;
}
function startGame() {
    unlockAudio(); bgMusic.play().catch(e => console.log("Audio waiting"));
    document.getElementById('start-overlay').style.display = 'none';
    isPaused = false; update();
}
function toggleMute() { isMuted = !isMuted; bgMusic.muted = isMuted; document.getElementById('mute-btn').innerText = isMuted ? 'ðŸ”‡' : 'ðŸ”Š'; }
function playTone(freq, type, duration) {
    if (isMuted || !audioUnlocked) return;
    const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
    osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + duration);
}

// --- DATA ---
const ringStory = ["Underwater: Dante learns to breathe.", "Pandora: Curiosity opens new colors.", "Minecraft: Dante rebuilds patterns.", "Lego World: Play with structure.", "Rainforest: Trust growth.", "Outer Space: Find stillness.", "Jungle: Follow instinct.", "School: Every mis-drop is a lesson.", "Sun Surface: Hold your shape.", "Dream World: Wake up inside your imagination."];
const themes = [
    { name: "Underwater World", bg: "rgba(0, 168, 255, 0.3)", target: 30, speed: 1000 },
    { name: "Pandora", bg: "rgba(106, 13, 173, 0.3)", target: 60, speed: 900 },
    { name: "Minecraft", bg: "rgba(124, 252, 0, 0.3)", target: 90, speed: 800 },
    { name: "Legoworld", bg: "rgba(255, 0, 0, 0.3)", target: 120, speed: 750 },
    { name: "Rainforest", bg: "rgba(0, 100, 0, 0.3)", target: 150, speed: 700 },
    { name: "Outer Space", bg: "rgba(0, 0, 34, 0.5)", target: 180, speed: 650 },
    { name: "Jungle", bg: "rgba(34, 139, 34, 0.3)", target: 210, speed: 600 },
    { name: "School", bg: "rgba(47, 79, 79, 0.3)", target: 240, speed: 550 },
    { name: "Sun Surface", bg: "rgba(255, 69, 0, 0.3)", target: 270, speed: 500 },
    { name: "Dream World", bg: "rgba(255, 182, 193, 0.4)", target: 350, speed: 450 }
];

// --- TOUCH DRAG SYSTEM ---
let touchStartX = 0, touchStartY = 0, didMove = false;

canvas.addEventListener('touchstart', e => {
    if (isPaused) return;
    touchStartX = e.touches[0].clientX; touchStartY = e.touches[0].clientY;
    didMove = false;
}, {passive: false});

canvas.addEventListener('touchmove', e => {
    if (isPaused) return;
    e.preventDefault();
    const touchX = e.touches[0].clientX, touchY = e.touches[0].clientY;
    const deltaX = touchX - touchStartX, deltaY = touchY - touchStartY;
    
    // Distinguish Move from Tap
    if (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10) didMove = true;

    // Horizontal Move Step
    if (Math.abs(deltaX) > 30) {
        playerMove(deltaX > 0 ? 1 : -1); touchStartX = touchX;
    }

    // Sticky Soft Drop
    if (deltaY > 50) startDrop();
}, {passive: false});

canvas.addEventListener('touchend', () => {
    if (!isPaused && !didMove) playerRotate(1); // Real Tap
    stopDrop();
});

// --- ENGINE ---
const canvas_ctx = canvas.getContext('2d');
const h_ctx = hctx, n_ctx = nctx;
const GRID_W = 10, GRID_H = 20, SCALE = 20;
canvas_ctx.scale(SCALE, SCALE); h_ctx.scale(12, 12); n_ctx.scale(12, 12);
const colors = [null, '#FF1493', '#FFD700', '#A020F0', '#00E5FF', '#FF4500', '#39FF14', '#FF0000'];

function draw() {
    canvas_ctx.fillStyle = themes[currentLevelIndex].bg; canvas_ctx.fillRect(0, 0, canvas.width, canvas.height);
    canvas_ctx.strokeStyle = "rgba(255, 255, 255, 0.15)"; canvas_ctx.lineWidth = 0.03;
    for(let x=0; x<=GRID_W; x++) { canvas_ctx.beginPath(); canvas_ctx.moveTo(x,0); canvas_ctx.lineTo(x,GRID_H); canvas_ctx.stroke(); }
    for(let y=0; y<=GRID_H; y++) { canvas_ctx.beginPath(); canvas_ctx.moveTo(0,y); canvas_ctx.lineTo(GRID_W,y); canvas_ctx.stroke(); }
    drawMatrix(canvas_ctx, arena, {x: 0, y: 0});
    const ghost = {x: player.pos.x, y: player.pos.y};
    while (!collide(arena, {pos: ghost, matrix: player.matrix})) ghost.y++; ghost.y--;
    drawMatrix(canvas_ctx, player.matrix, ghost, true);
    drawMatrix(canvas_ctx, player.matrix, player.pos);
    n_ctx.clearRect(0,0,5,5); drawMatrix(n_ctx, nextPiece, {x:0, y:0});
    h_ctx.clearRect(0,0,5,5); if (heldPiece) drawMatrix(h_ctx, heldPiece, {x:0, y:0});
}

function drawRing(ctx, x, y, value, isGhost = false) {
    ctx.globalAlpha = isGhost ? 0.3 : 1;
    const cx = x + 0.5, cy = y + 0.5;
    if (!isGhost && (value === 1 || value === 2)) {
        ctx.fillStyle = colors[value];
        ctx.beginPath(); ctx.arc(cx - 0.25, cy - 0.35, 0.15, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + 0.25, cy - 0.35, 0.15, 0, Math.PI * 2); ctx.fill();
    }
    ctx.beginPath(); ctx.arc(cx, cy, 0.42, 0, Math.PI * 2);
    ctx.fillStyle = colors[value]; ctx.fill();
    ctx.strokeStyle = 'white'; ctx.lineWidth = 0.08; ctx.stroke();
    ctx.globalAlpha = 1;
}

function drawMatrix(ctx, matrix, offset, isGhost = false) {
    matrix.forEach((row, y) => row.forEach((v, x) => { if (v !== 0) drawRing(ctx, x + offset.x, y + offset.y, v, isGhost); }));
}

function arenaSweep() {
    let rowCount = 0;
    for (let y = arena.length - 1; y >= 0; --y) {
        if (arena[y].every(v => v !== 0)) {
            arena.splice(y, 1); arena.unshift(new Array(GRID_W).fill(0));
            rowCount++; y++;
        }
    }
    if (rowCount > 0) {
        totalLines += rowCount; player.score += rowCount * 10;
        playTone(523, 'sine', 0.2); updateUI();
        danteAvatar.style.transform = 'scale(1.4) translateY(-15px)';
        setTimeout(() => danteAvatar.style.transform = 'scale(1) translateY(0)', 300);
    }
}

function updateUI() {
    document.getElementById('score').innerText = player.score;
    document.getElementById('lines-count').innerText = totalLines;
    const th = themes[currentLevelIndex];
    const prev = currentLevelIndex > 0 ? themes[currentLevelIndex - 1].target : 0;
    progressFill.style.width = Math.max(0, Math.min(100, ((totalLines - prev) / (th.target - prev) * 100))) + '%';
    
    if (currentLevelIndex === themes.length - 1 && totalLines >= th.target) { showOverlay("YOU REACHED DREAM WORLD!", "Dante won!", true); return; }
    if (totalLines >= th.target && currentLevelIndex < themes.length - 1) {
        currentLevelIndex++; dropInterval = themes[currentLevelIndex].speed;
        levelTitle.innerText = themes[currentLevelIndex].name;
        playTone(880, 'square', 0.5); showOverlay(themes[currentLevelIndex].name, ringStory[currentLevelIndex], false);
    }
}

function showOverlay(title, text, isWin) {
    isPaused = true; bgMusic.pause();
    overlayTitle.innerText = title; overlayText.innerText = text;
    document.getElementById('win-image').style.display = isWin ? 'block' : 'none';
    overlayPrimaryBtn.innerText = isWin ? "PLAY AGAIN" : (title === "STACKED OUT!" ? "START AGAIN" : "CONTINUE");
    overlay.style.display = 'flex';
}

function resumeGame() {
    if (overlayPrimaryBtn.innerText !== "CONTINUE") softReset();
    else { overlay.style.display = 'none'; isPaused = false; if(!isMuted) bgMusic.play(); update(); }
}

function softReset() {
    arena.forEach(row => row.fill(0)); totalLines = 0; player.score = 0; currentLevelIndex = 0;
    heldPiece = null; nextPiece = null; dropInterval = themes[0].speed;
    levelTitle.innerText = themes[0].name; updateUI();
    overlay.style.display = 'none'; isPaused = false;
    playerReset(); if(!isMuted) bgMusic.play(); update();
}

function collide(arena, p) {
    const [m, o] = [p.matrix, p.pos];
    for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) return true;
        }
    }
    return false;
}

function playerReset() {
    const pcs = 'ILJOTSZ';
    player.matrix = nextPiece || createPiece(pcs[Math.random() * pcs.length | 0]);
    nextPiece = createPiece(pcs[Math.random() * pcs.length | 0]);
    player.pos.y = 0; player.pos.x = (GRID_W / 2 | 0) - (player.matrix[0].length / 2 | 0);
    canHold = true;
    if (collide(arena, player)) { playTone(150, 'sawtooth', 0.5); showOverlay("STACKED OUT!", "Try again!", false); }
}

function createPiece(t) {
    if (t === 'I') return [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]];
    if (t === 'L') return [[0,2,0],[0,2,0],[0,2,2]];
    if (t === 'J') return [[0,3,0],[0,3,0],[3,3,0]];
    if (t === 'O') return [[4,4],[4,4]];
    if (t === 'Z') return [[5,5,0],[0,5,5],[0,0,0]];
    if (t === 'S') return [[0,6,6],[6,6,0],[0,0,0]];
    if (t === 'T') return [[0,7,0],[7,7,7],[0,0,0]];
}

function playerDrop() {
    player.pos.y++;
    if (collide(arena, player)) {
        player.pos.y--; merge(arena, player); arenaSweep(); playerReset();
        playTone(200, 'sine', 0.1);
    }
    dropCounter = 0;
}

function merge(arena, p) { p.matrix.forEach((row, y) => row.forEach((v, x) => { if (v !== 0) arena[y + p.pos.y][x + p.pos.x] = v; })); }
function playerMove(dir) { player.pos.x += dir; if (collide(arena, player)) player.pos.x -= dir; else playTone(400, 'sine', 0.05); }

function playerRotate(d) {
    const p = player.pos.x; let o = 1; rotate(player.matrix, d);
    while (collide(arena, player)) { player.pos.x += o; o = -(o + (o > 0 ? 1 : -1)); if (o > 4) { rotate(player.matrix, -d); player.pos.x = p; return; } }
    playTone(600, 'sine', 0.05);
}
function rotate(m, d) {
    for (let y = 0; y < m.length; ++y) { for (let x = 0; x < y; ++x) { [m[x][y], m[y][x]] = [m[y][x], m[x][y]]; } }
    if (d > 0) m.forEach(r => r.reverse()); else m.reverse();
}
function playerHold() {
    if (!canHold) return;
    if (!heldPiece) { heldPiece = player.matrix; playerReset(); }
    else { const t = player.matrix; player.matrix = heldPiece; heldPiece = t; player.pos.y = 0; player.pos.x = (GRID_W / 2 | 0) - (player.matrix[0].length / 2 | 0); }
    canHold = false; playTone(300, 'sine', 0.1);
}

document.addEventListener('keydown', e => {
    if (isPaused) return;
    if (e.keyCode === 37) playerMove(-1); else if (e.keyCode === 39) playerMove(1);
    else if (e.keyCode === 40) startDrop(); else if (e.keyCode === 38 || e.keyCode === 32) playerRotate(1);
    else if (e.keyCode === 72 || e.keyCode === 16) playerHold();
});
document.addEventListener('keyup', e => { if (e.keyCode === 40) stopDrop(); });

let dropCounter = 0, dropInterval = 1000, lastTime = 0, isPaused = true;
function startDrop() { dropInterval = 50; } function stopDrop() { dropInterval = themes[currentLevelIndex].speed; }

function update(t = 0) {
    if (isPaused) return;
    const dt = t - lastTime; lastTime = t; dropCounter += dt;
    if (dropCounter > dropInterval) playerDrop();
    draw(); requestAnimationFrame(update);
}

const arena = Array.from({length: GRID_H}, () => Array(GRID_W).fill(0));
const player = { pos: {x: 0, y: 0}, matrix: null };
let nextPiece = null, heldPiece = null, canHold = true, totalLines = 0, currentLevelIndex = 0;

playerReset(); draw();
</script>
</body>
</html>
