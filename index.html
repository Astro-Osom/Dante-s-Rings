<!DOCTYPE html>
<html>
<head>
    <title>Dante's Rings</title>
    <link rel="apple-touch-icon" href="Dante_App_Logo.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        :root { --accent: #FF1493; }
        body { 
            transition: background 1s ease; font-family: 'Comic Sans MS', sans-serif; 
            overflow: hidden; touch-action: none; margin: 0;
            display: flex; flex-direction: column; align-items: center; justify-content: space-between;
            background: #87CEEB; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            height: 100vh; width: 100vw;
        }
        #ui-header { width: 100%; text-align: center; padding-top: 5px; z-index: 10; }
        
        /* New Layout: Maximize Game Space */
        #main-layout { 
            display: flex; align-items: center; justify-content: center; 
            gap: 5px; width: 98%; height: 75vh; position: relative; 
        }
        
        .sidebar { display: flex; flex-direction: column; gap: 5px; width: 60px; height: 100%; justify-content: center; }
        .box { background: rgba(255, 255, 255, 0.3); border: 3px solid #FFF; border-radius: 12px; height: 60px; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        .box-label { font-size: 10px; font-weight: bold; text-align: center; }

        #game-container { 
            position: relative; height: 100%; border: 6px solid #FFF; 
            border-radius: 25px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); 
            background: #000; overflow: hidden; display: flex;
        }
        canvas#tetris { height: 100%; width: auto; aspect-ratio: 1 / 2; display: block; border-radius: 18px; }
        
        #dante-character-box { position: absolute; left: 5px; bottom: 5px; width: 60px; height: 60px; z-index: 5; }
        #dante-character-box img { width: 100%; height: 100%; object-fit: contain; filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.3)); transition: 0.2s; }

        #progress-container { width: 80%; height: 10px; background: rgba(0,0,0,0.3); border-radius: 10px; border: 2px solid #FFF; overflow: hidden; margin-bottom: 5px; }
        #progress-fill { width: 0%; height: 100%; background: #39FF14; transition: width 0.3s; }

        .controls { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; padding: 10px; width: 100%; max-width: 500px; height: 15vh; }
        button { height: 100%; border-radius: 15px; border: none; background: #FFF; font-size: 24px; box-shadow: 0 4px #CCC; cursor: pointer; }
        #mute-btn { position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.2); border: 2px solid #FFF; border-radius: 50%; width: 40px; height: 40px; font-size: 20px; display: flex; align-items: center; justify-content: center; z-index: 100; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: none; flex-direction: column; align-items: center; justify-content: center; border-radius: 18px; z-index: 50; padding: 10px; box-sizing: border-box; text-align: center; }
        #win-image { width: 150px; height: auto; margin-bottom: 10px; display: none; border-radius: 15px; }
    </style>
</head>
<body onpointerdown="unlockAudio()">

    <div id="mute-btn" onclick="toggleMute()">üîä</div>

    <div id="ui-header">
        <b id="level-title">Underwater World</b><br>
        <small style="font-size: 12px;">Score: <span id="score">0</span> | Next Level in: <span id="lines-left">30</span></small>
    </div>

    <div id="progress-container"><div id="progress-fill"></div></div>
    
    <div id="main-layout">
        <div class="sidebar">
            <div class="box-label">Hold</div>
            <div class="box"><canvas id="hold-canvas" width="50" height="50"></canvas></div>
        </div>
        <div id="game-container">
            <div id="dante-character-box"><img src="Dante_App_Logo.png" id="dante-img"></div>
            <canvas id="tetris" width="200" height="400"></canvas>
            <div id="overlay">
                <img id="win-image" src="Youwin.png">
                <h2 id="overlay-title" style="margin:5px">PAUSED</h2>
                <p id="overlay-text" style="max-width: 180px; font-size: 12px; line-height: 1.3; margin:5px"></p>
                <button id="overlay-button" onclick="overlayPrimaryAction()" style="width: 120px; height: 40px; font-size: 16px;">RESUME</button>
            </div>
        </div>
        <div class="sidebar">
            <div class="box-label">Next</div>
            <div class="box"><canvas id="next-canvas" width="50" height="50"></canvas></div>
        </div>
    </div>

    <div class="controls">
        <button onpointerdown="playerMove(-1)">‚¨ÖÔ∏è</button>
        <button onpointerdown="playerRotate(1)">üîÑ</button>
        <button onpointerdown="playerMove(1)">‚û°Ô∏è</button>
        <button onpointerdown="playerHold()">üì¶</button>
        <button onpointerdown="startDrop()" onpointerup="stopDrop()" onpointerleave="stopDrop()">‚¨áÔ∏è</button>
    </div>

<script>
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
// FIXED PATH: Extension changed from .mp4 to .m4a
const bgMusic = new Audio('Dantesgamemusic.m4a');
bgMusic.loop = true; bgMusic.volume = 0.4;
let audioUnlocked = false; let isMuted = false;

function unlockAudio() { 
    if (!audioUnlocked) {
        if (audioCtx.state === 'suspended') { audioCtx.resume(); }
        bgMusic.play().catch(e => console.log("Waiting for user interaction..."));
        audioUnlocked = true;
    }
}

function toggleMute() { isMuted = !isMuted; bgMusic.muted = isMuted; document.getElementById('mute-btn').innerText = isMuted ? 'üîá' : 'üîä'; }

function playTone(freq, type, duration) {
    if (!audioUnlocked || isMuted) return;
    const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
    osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + duration);
}

const ringStory = [
    "Underwater: Dante learns to breathe beneath the surface of his own feelings.",
    "Pandora: Curiosity opens new colors in Dante's sky.",
    "Minecraft: Dante discovers he can rebuild any pattern he breaks.",
    "Lego World: Dante plays with structure instead of fearing it.",
    "Rainforest: Dante trusts growth he cannot yet see.",
    "Outer Space: Dante finds stillness in the vast unknown.",
    "Jungle: Dante follows instinct, moving piece by piece.",
    "School: Dante realizes every mis-drop is a lesson.",
    "Sun Surface: Dante holds his shape even in the heat.",
    "Dream World: Dante wakes up inside his own imagination."
];

const themes = [
    { name: "Underwater World", bg: "#00a8ff", body: "#005b96", target: 30, speed: 1000 },
    { name: "Pandora", bg: "#6a0dad", body: "#32004f", target: 60, speed: 900 },
    { name: "Minecraft", bg: "#87CEEB", body: "#556b2f", target: 90, speed: 800 },
    { name: "Legoworld", bg: "#FF6347", body: "#b22222", target: 120, speed: 700 },
    { name: "Rainforest", bg: "#00BFFF", body: "#004d00", target: 150, speed: 600 },
    { name: "Outer Space", bg: "#191970", body: "#000011", target: 180, speed: 500 },
    { name: "Jungle", bg: "#2E8B57", body: "#1a471a", target: 210, speed: 450 },
    { name: "School", bg: "#4682B4", body: "#1c2e2e", target: 240, speed: 400 },
    { name: "Sun Surface", bg: "#FF4500", body: "#ff4500", target: 270, speed: 350 },
    { name: "Dream World", bg: "#FFB6C1", body: "#d8bfd8", target: 350, speed: 300 }
];

const colors = [null, '#FF1493', '#FFEA00', '#A020F0', '#00E5FF', '#FF4500', '#39FF14', '#FF0000'];
let clouds = [ {x: 2, y: 3, s: 1.5, d: 0.005}, {x: 8, y: 6, s: 1.2, d: 0.008}, {x: 1, y: 12, s: 1.8, d: 0.004} ];

const canvas = document.getElementById('tetris');
const context = canvas.getContext('2d');
const hctx = document.getElementById('hold-canvas').getContext('2d');
const nctx = document.getElementById('next-canvas').getContext('2d');
const danteImg = document.getElementById('dante-img');
const overlay = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlay-title');
const overlayText = document.getElementById('overlay-text');
const overlayButton = document.getElementById('overlay-button');
const winImg = document.getElementById('win-image');

let overlayMode = "pause";
const GRID_W = 10, GRID_H = 20, SCALE = 20;
context.scale(SCALE, SCALE); hctx.scale(12, 12); nctx.scale(12, 12);

function draw() {
    context.fillStyle = themes[currentLevelIndex].bg;
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // Cloud Drift
    clouds.forEach(c => {
        c.x += c.d; if (c.x > GRID_W + 2) c.x = -4;
        context.fillStyle = "rgba(255, 255, 255, 0.3)";
        context.beginPath(); context.arc(c.x, c.y, c.s, 0, Math.PI * 2); context.fill();
    });

    // Guide Grid
    context.strokeStyle = "rgba(255, 255, 255, 0.15)"; context.lineWidth = 0.02;
    for (let x = 0; x <= GRID_W; x++) { context.beginPath(); context.moveTo(x, 0); context.lineTo(x, GRID_H); context.stroke(); }
    for (let y = 0; y <= GRID_H; y++) { context.beginPath(); context.moveTo(0, y); context.lineTo(GRID_W, y); context.stroke(); }

    drawMatrix(context, arena, {x: 0, y: 0});
    const ghost = {x: player.pos.x, y: player.pos.y};
    while (!collide(arena, {pos: ghost, matrix: player.matrix})) ghost.y++; ghost.y--;
    drawMatrix(context, player.matrix, ghost, true);
    drawMatrix(context, player.matrix, player.pos);

    nctx.clearRect(0,0,5,5); drawMatrix(nctx, nextPiece, {x:0, y:0});
    hctx.clearRect(0,0,5,5); if (heldPiece) drawMatrix(hctx, heldPiece, {x:0, y:0});
}

function drawRing(ctx, x, y, value, isGhost = false) {
    ctx.globalAlpha = isGhost ? 0.3 : 1;
    const cx = x + 0.5, cy = y + 0.5;
    if (!isGhost && (value === 1 || value === 2)) {
        ctx.fillStyle = colors[value];
        ctx.beginPath(); ctx.arc(cx - 0.25, cy - 0.35, 0.15, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + 0.25, cy - 0.35, 0.15, 0, Math.PI * 2); ctx.fill();
    }
    ctx.beginPath(); ctx.arc(cx, cy, 0.42, 0, Math.PI * 2);
    ctx.fillStyle = colors[value]; ctx.fill();
    ctx.strokeStyle = 'white'; ctx.lineWidth = 0.05; ctx.stroke();
    ctx.globalAlpha = 1;
}

function drawMatrix(ctx, matrix, offset, isGhost = false) {
    matrix.forEach((row, y) => row.forEach((v, x) => { if (v !== 0) drawRing(ctx, x + offset.x, y + offset.y, v, isGhost); }));
}

function arenaSweep() {
    let rowCount = 0;
    for (let y = arena.length - 1; y >= 0; --y) {
        if (arena[y].every(v => v !== 0)) {
            arena.splice(y, 1); arena.unshift(new Array(GRID_W).fill(0));
            rowCount++; y++;
        }
    }
    if (rowCount > 0) {
        totalLines += rowCount; player.score += rowCount * 10;
        playTone(440 + (rowCount * 100), 'sine', 0.3);
        updateUI();
        danteImg.style.transform = 'scale(1.3) translateY(-10px)';
        setTimeout(() => danteImg.style.transform = 'scale(1) translateY(0)', 300);
    }
}

function updateUI() {
    document.getElementById('score').innerText = player.score;
    const th = themes[currentLevelIndex];
    const prevTarget = currentLevelIndex > 0 ? themes[currentLevelIndex - 1].target : 0;
    const progress = totalLines - prevTarget;
    const needed = th.target - prevTarget;
    document.getElementById('lines-left').innerText = Math.max(0, th.target - totalLines);
    document.getElementById('progress-fill').style.width = Math.max(0, Math.min(100, (progress / needed * 100))) + '%';

    if (currentLevelIndex === themes.length - 1 && totalLines >= th.target) { showWinOverlay(); return; }
    if (totalLines >= th.target && currentLevelIndex < themes.length - 1) {
        currentLevelIndex++; dropInterval = themes[currentLevelIndex].speed;
        document.body.style.background = themes[currentLevelIndex].body;
        document.getElementById('level-title').innerText = themes[currentLevelIndex].name;
        playTone(880, 'square', 0.5); showStoryOverlay(currentLevelIndex);
    }
}

function showStoryOverlay(idx) {
    overlayMode = "story"; isPaused = true; bgMusic.pause();
    winImg.style.display = 'none';
    overlayTitle.innerText = themes[idx].name;
    overlayText.innerText = ringStory[idx] || "";
    overlayButton.innerText = "KEEP EXPLORING";
    overlay.style.display = 'flex';
}

function showWinOverlay() {
    overlayMode = "win"; isPaused = true; bgMusic.pause();
    winImg.style.display = 'block';
    overlayTitle.innerText = "YOU REACHED DREAM WORLD!";
    overlayText.innerText = "Dante has climbed every ring. The patterns you play now are the Self you're rehearsing.";
    overlayButton.innerText = "PLAY AGAIN";
    overlay.style.display = 'flex';
}

function showGameOverOverlay() {
    overlayMode = "gameover"; isPaused = true; bgMusic.pause();
    winImg.style.display = 'none';
    overlayTitle.innerText = "STACKED OUT!";
    overlayText.innerText = "The rings reached the top. Take a breath and try again!";
    overlayButton.innerText = "START AGAIN";
    overlay.style.display = 'flex';
}

function softReset() {
    arena.forEach(row => row.fill(0));
    totalLines = 0; player.score = 0; currentLevelIndex = 0;
    heldPiece = null; nextPiece = null;
    dropInterval = themes[0].speed;
    document.body.style.background = themes[0].body;
    document.getElementById('level-title').innerText = themes[0].name;
    updateUI();
    overlay.style.display = 'none';
    isPaused = false;
    playerReset();
    if (!isMuted) bgMusic.play();
    update();
}

function overlayPrimaryAction() {
    unlockAudio();
    if (overlayMode === "pause" || overlayMode === "story") { 
        overlay.style.display = 'none'; isPaused = false; if(!isMuted) bgMusic.play(); update(); 
    } else {
        softReset();
    }
}

function collide(arena, p) {
    const [m, o] = [p.matrix, p.pos];
    for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) return true;
        }
    }
    return false;
}

function merge(arena, p) {
    p.matrix.forEach((row, y) => row.forEach((v, x) => { if (v !== 0) arena[y + p.pos.y][x + p.pos.x] = v; }));
}

function playerReset() {
    const pcs = 'ILJOTSZ';
    player.matrix = nextPiece || createPiece(pcs[Math.random() * pcs.length | 0]);
    nextPiece = createPiece(pcs[Math.random() * pcs.length | 0]);
    player.pos.y = 0; player.pos.x = (GRID_W / 2 | 0) - (player.matrix[0].length / 2 | 0);
    canHold = true;
    if (collide(arena, player)) { showGameOverOverlay(); }
}

function createPiece(t) {
    if (t === 'I') return [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]];
    if (t === 'L') return [[0, 2, 0], [0, 2, 0], [0, 2, 2]];
    if (t === 'J') return [[0, 3, 0], [0, 3, 0], [3, 3, 0]];
    if (t === 'O') return [[4, 4], [4, 4]];
    if (t === 'Z') return [[5, 5, 0], [0, 5, 5], [0, 0, 0]];
    if (t === 'S') return [[0, 6, 6], [6, 6, 0], [0, 0, 0]];
    if (t === 'T') return [[0, 7, 0], [7, 7, 7], [0, 0, 0]];
}

function playerDrop() {
    player.pos.y++;
    if (collide(arena, player)) {
        player.pos.y--; merge(arena, player); arenaSweep(); playerReset();
        playTone(200, 'sine', 0.1);
    }
    dropCounter = 0;
}

function playerMove(dir) { unlockAudio(); player.pos.x += dir; if (collide(arena, player)) player.pos.x -= dir; else playTone(600, 'sine', 0.05); }

function playerRotate(d) {
    unlockAudio(); const p = player.pos.x; let o = 1; rotate(player.matrix, d);
    while (collide(arena, player)) { player.pos.x += o; o = -(o + (o > 0 ? 1 : -1)); if (o > 4) { rotate(player.matrix, -d); player.pos.x = p; return; } }
    playTone(700, 'sine', 0.05);
}

function rotate(m, d) {
    for (let y = 0; y < m.length; ++y) { for (let x = 0; x < y; ++x) { [m[x][y], m[y][x]] = [m[y][x], m[x][y]]; } }
    if (d > 0) m.forEach(r => r.reverse()); else m.reverse();
}

function playerHold() {
    unlockAudio(); if (!canHold) return;
    if (!heldPiece) { heldPiece = player.matrix; playerReset(); }
    else { const t = player.matrix; player.matrix = heldPiece; heldPiece = t; player.pos.y = 0; player.pos.x = (GRID_W / 2 | 0) - (player.matrix[0].length / 2 | 0); }
    canHold = false; playTone(500, 'sine', 0.1);
}

document.addEventListener('keydown', e => {
    if (isPaused && e.keyCode !== 80) return;
    if (e.keyCode === 37) playerMove(-1);
    else if (e.keyCode === 39) playerMove(1);
    else if (e.keyCode === 40) startDrop();
    else if (e.keyCode === 38 || e.keyCode === 32) playerRotate(1);
    else if (e.keyCode === 72 || e.keyCode === 16) playerHold();
    else if (e.keyCode === 80) togglePause();
});
document.addEventListener('keyup', e => { if (e.keyCode === 40) stopDrop(); });

let dropCounter = 0, dropInterval = themes[0].speed, lastTime = 0, isPaused = false;
function togglePause() {
    unlockAudio();
    if (overlay.style.display === 'flex' && overlayMode === "pause") { overlay.style.display = 'none'; isPaused = false; if(!isMuted) bgMusic.play(); update(); }
    else { 
        overlayMode = "pause"; overlayTitle.innerText = "PAUSED"; overlayText.innerText = "Take a breath. Notice the pattern you're building."; 
        overlayButton.innerText = "RESUME"; overlay.style.display = 'flex'; isPaused = true; bgMusic.pause();
    }
}

function startDrop() { unlockAudio(); dropInterval = 50; }
function stopDrop() { dropInterval = themes[currentLevelIndex].speed; }

function update(t = 0) {
    if (isPaused) return;
    const dt = t - lastTime; lastTime = t; dropCounter += dt;
    if (dropCounter > dropInterval) playerDrop();
    draw(); requestAnimationFrame(update);
}

const arena = Array.from({length: GRID_H}, () => Array(GRID_W).fill(0));
const player = { pos: {x: 0, y: 0}, matrix: null, score: 0 };
let nextPiece = null, heldPiece = null, canHold = true, totalLines = 0, currentLevelIndex = 0;

playerReset(); update();
</script>
</body>
</html>
